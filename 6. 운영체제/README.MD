## 운영체제 - 틀린거 고쳐서 다시 써야 하는데 시간이 없다...

## 컴퓨터 시스템 자원을 관리하는 소프트웨어
## cpu(gpu) = 레지스터 + 
## 메모리
## 디스크
## IO장치 
## 네트워크장치


## 메모리 관리

- 메모리 관리는 메모리 관리자가 담당한다
- 메모리 관리자 = 운영체제의 관리 모듈 + MMU
- 3가지 정책으로 관리한다
    - 적재 정책 = 디스크에서 메모리로 프로세스를 반입할 시기를 결정(요구 적재 또는 예상 적재)
    - 배치 정책 = 디스크에 반입한 프로세스를 어느 위치에 적재할지 결정
    - 대치 정책 = 메모리가 부족한 경우 제거할 프로세스를 결정(FIFO / LRU 등등 다양)
- 메모리 = 주소의 연속
- 주소는 논리 주소와 물리 주소로 구분할 수 있다
- 이 사이의 변환을 MMU가 처리한다
    - 변환 방식은 고정 분할/동적 분할/페이징/세그멘테이션/페이지화된 세그멘테이션 등이 있다
    - 물리적 주소를 알지 못하면 CPU가 프로세스를 실행할 수 없으므로 두 주소를 매핑, 즉 바인딩 과정이 필수다
    - 바인딩 과정을 구체적으로 보면 총 3단계이다
        - 컴파일 단계: 원시 코드를 컴파일러가 목적 파일로 변환.
        - 만약 이 과정에서 메모리에 적재될 위치를 컴파일러가 알 수 있다면 물리적 주소를 생성한다.
        - 알지 못하는 경우 상대 주소를 사용해서 컴파일을 한다
        - 적재 단계: 링커에 의해 라이브러리 파일과 다른 목적파일을 모두 연결하고 로더가 메모리에 적재 준비.
        - 만약 상대 주소인 경우에는 이 단계에서 적재가 연기된다
        - 실행 단계: 로더가 메모리에 결과를 적재하면 물리적 주소로 변환
        - 프로세스가 동일한 장소에서 작동하면 적재 시간에 바인딩을 할 수 있으나 프로세스를 실행하는 도중에
        - 한 세그먼트에서 다른 세그먼트로 이동하는 경우에는 바인딩을 수행 시간까지 연기한다
        - 즉 동적으료 메모리에 적재하게 된다
- 동적 적재란?
    - 바인딩을 최대한 늦춰서 실행 직전에 주소를 확정하면 메모리를 효율적으로 사용할 수 있다
    - 모든 루틴을 메모리에 적재하지 않고 교체 가능한 형태로 디스크에 저장한 후
    - 메인 프로그램만 먼저 메모리에 적재한다
    - 메인 프로그램이 다른 루틴을 요구하는 경우 적재되어 있는지 확인하고 없다면 해당 루틴을 디스크에서 호출하면서
    - 프로그램의 주소 테이블을 갱신한다
- 중첩이란?
  - 메모리 공간이 부족한 경우 당장 필요한 부분만 먼저 메모리에서 실행하고 필요한 부분은 새로운 읽기를 통해 메모리로 적재해서 사용
  - 잘 쓰이지 않는다
- 스와핑이란?
  - 