

###########################################################################################
객체지향 프로그래밍 탄생 배경
절차적 프로그래밍
전역 변수로 데이터를 관리하고 그 데이터를 사용하는 전역 함수로 프로그램을 만드는 프로그래밍 방식
너무 많은 전역 변수와 함수들은 이름이 겹치기 시작했고, 복잡한 상태 관리의 어려움이 발생
이 문제를 해결하기 위해 변수와 함수의 이름을 일정 블록 안에서만 유효하게 만드는 namespace가 등장
namespace가 조금 더 발전해서 struct가 등장
여기까지 c언어

객체지향 프로그래밍
c언어의 struct를 더 발전시켜 c++에서 최초로 데이터와 함수를 클래스로 묶고, 객체끼리의 상호작용으로 프로그램을 만드는 프로그래밍 방식인 객체지향 프로그래밍이 탄생했다.
데이터를 속성, 함수를 메소드라고 부른다.
###########################################################################################
객체지향 프로그래밍의 4대 특성
추상화: 객체를 생성하고 사용하는 쪽에서는 클래스의 내부 구현을 몰라도 객체를 사용하는데 문제가 없어야 한다.
캡슐화: 객체 내부의 속성은 감추고, 메소드를 통해서만 속성에 접근할 수 있도록 접근 권한을 제한해야 한다.
상속: 부모 클래스의 프로퍼티와 메소드를 자식 클래스가 재구현할 필요가 없다. 구체화하면 아래와 같다.
3-1. 일반적인 부모 클래스 = 자식에게 프로퍼티와 메소드를 물려준다. 단 private인 경우 물려줄 수 없다.
3-2. 추상 클래스 = 부모 클래스의 일종으로, 추상 메소드를 가질 수 있고, 자식 클래스는 이 추상 메소드를 반드시 오버라이딩해야 할 의무가 생긴다.
3-3. 인터페이스 = 일종의 자격증과 같은 역할을 한다. 인터페이스를 상속받은 자식 클래스는, 인터페이스의 모든 메소드를 반드시 오버라이딩해야 할 의무가 생긴다. 추상 클래스와의 차이는, 하나의 자식이 여러개의 인터페이스를 상속받을 수 있다는 점이다.
다형성: 부모 클래스를 상속받은 자식 클래스는 부모 클래스의 메소드를 상속받아 내부 기능을 수정할 수 있는데, 이를 오버라이드라고 부른다. 따라서 서로 다른 자식 객체들은 같은 메소드를 호출해도 각자 다른 기능을 수행할 수 있다.
###########################################################################################
객체지향의 5대 원칙
단일 책임 원칙: 클래스, 함수와 같은 프로그램의 부품은 오직 하나의 일만을 책임져야 한다
개방 폐쇄 원칙: 인터페이스등을 활용해서, 클래스에 기능을 추가할 때 기존의 코드를 건드리지 않고 기능을 확장할 수 있어야 한다.(디자인 패턴의 전략 패턴을 참고)
인터페이스 분리 원칙: 하나의 인터페이스에 여러 기능을 넣어서 자식에게 상속시키는 것 보다는, 서로 다른 기능은 서로 다른 인터페이스로 분리해서 만들고 자식 클래스가 다중 상속을 받는것이 좋다.
의존관계 역전 원칙: 상속은 구체적인 클래스보다는 인터페이스나 추상 클래스로부터 상속을 받는것이 좋다. 구체적인 클래스는 변화할 가능성이 크지만, 인터페이스와 추상클래스는 내부 구현이 없이 껍데기만 만들기 때문에 변화할 가능성이 적기 때문이다.
리스코프 치환 원칙: 부모와 자식의 인스터스를 치환해도 문제가 없어야 한다.(이건 솔직히 뭔 소린지 모르겠음)
###########################################################################################
자바스크립트의 객체지향은 c++과 자바의 객체지향과 어떻게 다른가?
객체지향은 매우 훌륭한 방법론이지만, 상속, 다향성, 인터페이스, 부모 클래스 등을 잘 이해하고 디자인 패턴을 적용해서 초기 설계를 매우 잘 해야 했다. 자바스크립트의 창시자는 이런 객체지향의 어려운 초기 설계를 비판적으로 생각했고, 최대한 그 복잡함을 없애려고 했다. 그래서 그냥 클래스 지원을 없애버리고ㄷㄷ 객체지향 흉내를 아래처럼 내기로 했다.

우선 평범하게 let object = { a : 1 }과 같은 방식으로 쉽게 객체를 만들고 멤버 변수 세팅할 수 있게 하자.
생성자 딱히 없는데, 객체의 prototype 변수에 어떤 메소드를 대입하면 그 메소드가 생성자처럼 작동하게 하자.
객체 내부 변수에 함수를 정의하면 함수 내부의 this 변수에 해당 객체를 그대로 넘겨주자.

상속도 상속의 느낌을 내면 그만이므로 상속이 아니라 객체의 __proto__ 변수에 상위 객체를 연결해서, 내 객체 안에 원하는 변수나 함수가 없으면 __proto__ 변수를 타고 상위 객체에 가서 찾는 형태로 만든다. 그럼 상속받은거랑 결론이 같다.
만약 내 객체 안에 찾는 변수나 함수가 있으면 그냥 그걸 쓰게 될 것이다. 이렇게 다형성도 해결된다.

그러나 클래스를 지원해 달라는 무수히 많은 개발자들의 요청에 의해… 지금은 이 과정을 잘 포장해서 그럴싸하게 클래스처럼 보이게 만들어졌다.

또한 추상 클래스, 인터페이스를 지원해 달라는 무수히 많은 개발자들의 요청에 의해… 타입스크립트를 설치하면 그럴싸하게 추상클래스와 인터페이스를 사용할 수 있는 것 처럼 만들어졌다.

마지막으로 자바, c++은 변수든 함수든 그 값이 정수인지, 문자인지 타입을 지정하도록 되어 있어서 오류가 날 확률이 적었는데, 자바스크립트는 그게 되지 않아서 이 역시 지원해달라는 요청이 많았고, 타입스크립트를 설치하면 그럴싸하게 타입을 지원하는 것 처럼 보이도록 만들어졌다.

이렇게 해서 현재는 타입스크립트를 쓰면 c++, 자바와 거의 비슷한 방식으로 객체지향 프로그래밍이 가능해졌다.
그러나 자바스크립트는 함수형 프로그래밍의 철학이 많이 들어있기 때문에, 두 프로그래밍 패러다임을 모두 가지고 있다고 해서 멀티패러다임 프로그래밍 언어라고 부른다. 즉 경우에 따라서 객체 지향적으로, 경우에 따라서는 함수형으로 프로그래밍을 할 수 있는 언어가 되었다. 이는 파이썬 역시 마찬가지.
###########################################################################################
가변 객체와 불변 객체
대표적인 가변 객체는 배열
배열에 값을 추가하면 추가되지만 배열의 주소는 바뀌지 않는다.

대표적인 불변 객체는 문자열, 불린, 숫자
예를 들어 a = 1;에서 a = 2를 하게 되면, 혹은 new 연산을 통해 새롭게 객체를 생성하면
기존의 a가 가르키던 메모리 주소에 존재하는 값 1은 불변 객체이기 때문에 바뀌지 않는다.
따라서 새로운 객체 2를 만들고 새로운 객체의 새로운 주소를 새로운 a에 할당하게 된다
원래 있던 객체 1은 가비지콜렉터가 나중에 메모리에서 삭제한다. 

커스텀 불변 객체를 직접 만드는 방법
클래스의 변수들을 private final로 선언하자
객체를 생성하기 위한 생성자 또는 정적 팩토리 메서드를 추가하라. 생성자를 선언하지 않으면 기본 생성자가 자동으로 생성되는데, 그러면 다른 클래스에서 해당 객체를 자유롭게 호출할 수 있다. 그렇기 때문에 내부 생성자를 만드는 대신 정적 팩토리 메소드를 통해 객체를 생성하도록 강요하는 것이 좋다.
또한 배열이나 컬렉션과 같은 객체들은 참조가 전달되어 수정 가능성이 있다. 그렇기 때문에 참조를 통해 변경이 가능한 경우에는 방어적 복사를 통해 값을 리턴해야 한다.
set 메소드를 제거한다
상속을 받아서 오버라이드 하면 변해버리니까 상속불가능하게 final 클래스로 만든다
생성자에서도 프로퍼티가 뮤터블 객체면 새롭게 만들어서 세팅한다

커스텀 불변 객체를 직접 만들어야 하는 경우는?
멀티스레드에서 공유변수의 문제가 크다면 불변객체로 만드는 것이 좋다
객체지향에서 생성자에서 내부 프로퍼티를 세팅하고 나면(디비에서 값을 읽어와서 객체를 만들고 나면) 더 이상 그 프로퍼티를 수정하지 않는 객체이기 때문에 서비스를 안정적으로 운영할 수 있도록 해준다

커스텀 불변 객체 생성시 존재하는 단점은?
객체가 가지는 값마다 새로운 객체가 필요하다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야 하기 때문에 성능저하를 발생시킬 수 있다.
###########################################################################################
핵심 디자인 패턴 7개 총정리
싱글톤 패턴
전략 패턴
어댑터 패턴
템플릿 패턴
프록시 패턴
팩토리 패턴
데코레이터 패턴
###########################################################################################
디자인 패턴 - 싱글톤 패턴
프로그램 실행 중에 최대 하나만 있어야 할 경우나 전역적으로 접근이 가능한 개체여야 할 경우
어떤 클래스에서 만들 수 있는 인스턴스 수를 하나로 제한하기 위해서 사용한다
static 변수를 직접 쓰는 대신 대신 굳이 싱글톤 패턴을 쓰는 이유는
static 변수는 전역 변수에 가깝지만 싱글톤 객체는 객체지향 패러다임에 맞기 때문
싱글톤은 객체이므로 생성자로 생성 시점을 제어할 수 없다
###########################################################################################
디자인 패턴 - 전략 패턴

간단히 말해서 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴입니다.

예를 들어, 기차( Train )와 버스( Bus ) 클래스가 있고, 이 두 클래스는 Movable 인터페이스를 구현했다고 가정하겠습니다.
그리고 Train과 Bus 객체를 사용하는 Client도 있습니다.


이 구조를 코드로 표현하면 다음과 같습니다.
기차는 선로를 따라 이동하고, 버스는 도로를 따라 이동합니다.
그러다 시간이 흘러 선로를 따라 움직이는 버스가 개발되었다고 가정해봅시다.

그러면 Bus의 move() 메서드를 다음과 같이 바꿔주기면 하면 끝납니다.
public void move(){
   System.out.println("선로를 따라 이동");
}

그런데 이렇게 수정하는 방식은 SOLID의 원칙 중 OCP( Open-Closed Principle )에 위배됩니다.
OCP에 의하면 기존의 move()를 수정하지 않으면서 행위가 수정되어야 하지만, 지금은 Bus의 move() 메서드를 직접 수정했지요.
또한 지금과 같은 방식의 변경은 시스템이 확장이 되었을 때 유지보수를 어렵게 합니다.
예를 들어, 버스와 같이 도로를 따라 움직이는 택시, 자가용, 고속버스, 오토바이 등이 추가된다고 할 때, 모두 버스와 같이 move() 메서드를 사용합니다.
만약에 새로 개발된 선로를 따라 움직이는 버스와 같이, 선로를 따라 움직이는 택시, 자가용, 고속버스 ... 등이 생긴다면,
택시, 자가용, 고속버스의 move() 메서드를 일일이 수정해야 할 뿐더러, 같은 메서드를 여러 클래스에서 똑같이 정의하고 있으므로 메서드의 중복이 발생하고 있습니다.

이번에는 위와 같이 선로를 따라 이동하는 버스가 개발된 상황에서 시스템이 유연하게 변경되고 확장될 수 있도록 전략 패턴을 사용해보도록 하겠습니다.

3)
이제 Train과 Bus 객체를 사용하는 Client를 구현할 차례입니다.
Train과 Bus 객체를 생성한 후에, 각 운송 수단이 어떤 방식으로 움직이는지 설정하기 위해 setMovableStrategy() 메서드를 호출합니다.
그리고 전략 패턴을 사용하면 프로그램 상으로 로직이 변경 되었을 때, 얼마나 유연하게 수정을 할 수 있는지 살펴보기 위해
선로를 따라 움직이는 버스가 개발되었다는 상황을 만들어 버스의 이동 방식 전략을 수정했습니다.
###########################################################################################
디자인 패턴 - 팩토리 패턴

팩토리 메서드는 객체를 생성하는 인터페이스는 미리 정의하지만, 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴이다. 다시 말해 여러 개의 서브 클래스를 가진 슈퍼 클래스가 있을 때 인풋에 따라 하나의 자식 클래스의 인스턴스를 리턴해 주는 방식이다.

아래 코드는 버거 자동 주문 기계이다. 거기서 음료 주문을 할 때 컵 크기를 고른다. 고객은 스몰, 미디엄, 라지를 선택할 뿐 실제 컵 용량(ml)을 모른다

Cup 클래스의 생성자는 private이다. 즉 Cup 클래스의 개체를 직접 생성할 수 없다. createOrNull() 정적 메서드에서 switch 문을 통해 Cup 개체를 생성해주는 것을 볼 수 있다.
생성자 대신 정적 메서드를 사용하는 것의 장점
null을 반환 가능
생성자는 생성이 불가능한 경우 예외를 던질 수밖에 없음
반환형이 없기 때문
아직 팩토리 메서드가 완성된 것은 아니다. 여기서 만약 모든 나라에서 사용할 수 있는 기계를 만든다면 어떻게 해야 할까? 즉 나라마다 small, medium, large의 크기가 다르다. 같은 large여도 나라마다 다르기 때문에 이를 구현하고 싶은 것이다. createOrNull()을 다형적으로 만든다. 그러나 static 메서드를 다형적으로 만들 수 없다 그래서 자식 클래스를 만들어야 한다. 
다형적으로 개체 생성 가능 따라서 이 패턴을 가상 생성자 패턴이라고도 함
생성자에서 오류 상황 감지 시 null 반환 가능
클라이언트는 본인에게 익숙한 인자를 통해 개체 생성 가능
팩토리 메서드 패턴은 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거하여 서로 간의 종속성을 낮추고, 결합도를 느슨하게 하며(Loosely Coupled), 확장을 쉽게 한다.
이렇듯 팩토리 메서드 패턴을 사용하게 되면 인스턴스를 필요로 하는 Application에서 Computer의 Sub 클래스에 대한 정보는 모른 채 인스턴스를 생성할 수 있게 된다. 이렇게 구현한다면 앞으로 Computer 클래스에 더 많은 Sub 클래스가 추가된다 할지라도 getComputer()를 통해 인스턴스를 제공받던 Application의 코드는 수정할 필요가 없게 된다.
###########################################################################################
디자인 패턴 - 어댑터 패턴

외부 라이브러리  클래스의 메소드 형태가 우리의 프로그램에서 사용하기 적당하지 않을 때
외부 라이브러리 클래스의 메소드를 변경하지 않고, 새로운 클래스를 만들어 기존 클래스를 감싸는 방식으로 해결하는 방법
또한 기존 클래스에 없는 기능을 추가하려고 할 떄 사용한다.
기본적인 패턴은 A 클래스의 어떤 getA()라는 메서드 시그니처가 있는데 마음에 안들어서 바꾼다고 해보자. 그러면 클래스 B를 만들고 클래스 B안에 클래스 A를 포함하는 것이다. 정확히 말하면 클래스 A로부터 만든 개체를 포함하는 것이다. 그리고 앞으로 클래스 B에 있는 getB() 메서드를 호출할 건데 이게 알아서 A의 getA()를 호출해주는 것이다. 즉 내가 호출할 때는 B만 사용하고 내부적으로는 getA()를 어떻게서든 사용하는 것.
###########################################################################################
디자인 패턴 - 프록시 패턴

프록시 패턴이 이루려는 목적도 비슷하다. 클래스 안에서 어떤 상태를 유지하는 게 여의치 않은 경우가 있다. 데이터가 너무 커서 미리 읽어 두면 메모리가 부족하고 개체 생성 시 데이터를 로딩하면 시간이 꽤 걸린다. 그리고 개체는 만들었으나 그 속의 데이터를 사용하지 않을 수도 있다. 이럴 경우 다음과 같은 방법을 통해 불필요한 데이터 로딩을 방지한다.
개체 생성 시에는 데이터 로딩에 필요한 정보만(예: 파일 위치) 기억해 둠
클라이언트가 실제로 데이터를 요청할 때 메모리에 로딩함
언제 지연 로딩을 사용하고 언제 즉시 로딩을 사용해야 할까? 요즘은 클라이언트가 내부 동작방법을 분명히 알고 그에 적합한 UI를 보여주는 방법이 더 사랑받는다. 따라서 요즘 세상에는 클래스가 남몰래 프록시 패턴을 사용하는 것보다 클라이언트에게 조작 권한을 주는 게 좋을 수 있다. 어떻게 하는 지 살펴보자.
###########################################################################################
디자인 패턴 - 옵저버 패턴

어느 순간 A가 바뀌면 B가 그것을 깨닫고 행동을 하게 되는 것이다 그런데 B가 한명만 있는 게 아니다.
여러 개가 있을 수 있다. B, C, D, E도 감시를 하고 있을 수도 있다 하지만 A는 하나이다.
A를 감시하며 A가 변하면 감시하고 있는 것들도 바뀌는 것이다. 이때 쓰는 패턴이 옵저버 패턴이다.
발행-구독(pub-sub) 패턴이라고도 부를 수 있다. pub-sub 패턴과의 차이는 발행자가 하나이다. 즉, pub-sub은 다대다 관계(many-to-many)이고 그걸 조율해주는 중간 클래스가 있을 뿐인 것이다.
###########################################################################################
