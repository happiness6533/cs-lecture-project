## 컴퓨터 네트워크

1. 현대의 컴퓨터 네트워크는 5개의 계층으로 구성된다

    - 어플리케이션 레이어: 메세지 = 헤더 + 데이터
    - 트랜스포트 레이어: 세그먼트 = 헤더 + 메세지
    - 네트워크 레이어: 패킷 = 헤더 + 세그먼트
    - 링크 레이어: 프레임 = 헤더 + 패킷
    - 피지컬 레이어: 보내고자 하는 정보를 전기 신호로 전환

2. 어플리케이션 레이어
    - 서로 다른 2개의 프로세스끼리 파이프 또는 소켓을 사용해서 데이터를 주고 받는다
    - 소켓 프로그래밍
        - os는 tcp 소켓과 udp 소켓을 지원한다
        - tcp 소켓을 사용해서 연결이 생성되는 과정
            - 서버
                - tcp 또는 udp 방식으로 소켓을 열고 포트에 바인딩한다
                - 백로그 숫자만큼 소켓을 생성하고 클라이언트의 접속을 리슨하며 무한 대기한다
            - 클라이언트
                - tcp 또는 udp 방식으로 소켓을 열고 포트에 바인딩한다
                - 서버에 커넥트한다
            - 3 way hand shaking
            - 프로토콜에 따라 데이터를 교환한다
            - 종료되면 양쪽 모두 소켓을 닫는다
        - http 프로토콜
            - tcp 프로토콜을 전제로 메세지의 헤더를 http 프로토콜에 맞게 작성하고 http 관련 데이터를 전송하는 프로토콜
            - 커넥션을 1회 사용하고 해제한다
        - socket 프로토콜
            - tcp 프로토콜을 전제로 메세지의 헤더에 socket 프로토콜에 맞게 작성하고 양방향으로 데이터를 전송하는 프로토콜
            - 한 번 맺은 커넥션을 지속적으로 사용한다

3. 트랜스포트 레이어
    - 멀티플렉싱과 디멀티플렉싱
        - 보내는 컴퓨터
        - 컴퓨터에는 많은 프로세스가 있고, 각각의 프로세스가 사용중인 소켓이 있는데
        - 다양한 소켓에서 전달해 주는 데이터를 모두 동일한 방식으로 세그먼트 > 패킷 > 데이터그램화 하는 것을 멀티플렉싱이라 한다

        - 받는 컴퓨터
        - 소켓을 통해 받은 데이터를 어플리케이션 레이어에서 정확하게 각각의 프로세스들에게 나누어 주는 것을 디멀티플렉싱이라 한다

        - 작동 원리
        - tcp의 경우
            - 네트워크 레이어에서 헤더를 검사하면 받은 패킷의 헤더에 출발지, 목적지의 아이피가 모두 적혀있다
            - 트랜스포트 레이어에서 헤더를 검사하면 받은 세그먼트의 헤더에 출발지, 목적지의 포트가 모두 적혀있다
            - 출발지와 목적지의 아이피와 포트가 모두 일치하는 소켓을 찾아서 정확한 프로세스에 데이터를 전달한다
            - 각각의 소켓을 담당하는 여러 쓰레드가 동시성으로 이러한 일들을 처리하고 있다
        - udp의 경우
            - 네트워크 레이어에서 헤더를 검사하면 받은 패킷의 헤더에 출발지, 목적지의 아이피가 모두 적혀있다
            - 트랜스포트 레이어에서 헤더를 검사하면 받은 세그먼트의 헤더에 출발지, 목적지의 포트가 모두 적혀있다
            - udp는 아이피만 같으면 데이터를 전달한다

    - 에러, 유실, 효율성, 유연성
        1. rdt 1.0: 유실
            - 에러 해결
            - 패킷을 한 번에 하나씩 전송
            - 패킷에 에러가 나는 경우를 아래의 방법으로 해결
                - 에러 체크썸
                - 피드백
                - 재전송
                - 시퀀스(0, 1) 넘버
        2. rdt 2.0: 효율성
            - 유실 해결
            - 패킷이 유실되는 경우를 대비
            - 타이머
        3. rdt 3.0 = rdt 1.0 + rdt 2.0
        4. go back n: 효율성
            - 효율 문제를 해결했다
            - 센더
                - 윈도우 사이즈 n개만큼 보냄
                - 그게 10 11 12 13이라고 치자
                - n개 전부 타이머 있음
                - n개중 하나라도 타이머 터지면 전부 재전송
                - 만약에 ack11을 받으면 윈도우를 12부터 시작하는걸로 슬라이딩함
                - 근데 ack11을 계속 보내니까
                - 12번 타이머가 결국 터짐
                - 그럼 12번부터 다시 윈도우 전부 재전송
                - 만약 정상 ack 받으면 윈도우가 바로바로 슬라이딩
            - 리시버
                - ack11 = 0부터 11까지 다 잘 받았음...12번 줘
                - 이 때 만약 13번 패킷이 먼저 도착하면?
                - 먼저 13번을 받으면 될텐데...안그럼
                - 13, 14, 15... 다 버림
                - 그리고 계속 12번 달라고 ack11을 계속 함
                - 하...
            - 센더
            - 만약 임의의 k번쨰 패킷이 유실되면
            - 거기에서 윈도우 사이즈만큼 보냇던걸
            - n만큼 뒤로 돌아와서 k번쨰부터 다시 전송
            - 문제점
                - 유실된건 12번뿐인데
                - 그거 하나떔에 n개를 다시 보내라고?
        5. selective repeat: 효율성
            - 효율 문제를 개선했다
            - 센더
                - 윈도우 사이즈 n개만큼 보냄
                - 그게 10 11 12 13이라고 치자
                - n개 전부 타이머 있음
                - 만약에 ack11을 받으면 윈도우를 12부터 시작하는걸로 슬라이딩
                -
                - 근데 ack11을 계속 보내니까
                - 12번 타이머가 결국 터짐
                - 그럼 12번만 재전송
                - 만약 정상 ack 받으면 윈도우가 바로바로 슬라이딩
            - 리시버
                - ack11 = 11번은 확실히 잘 받았음... 12번 줘
                - 이 때 만약 13번 패킷이 먼저 도착하면?
                - 이번엔 잘 받아서 버퍼에 넣어둠
                - 그리고 ack도 보내줌

            - 대체 번호를 몇 번까지 써야되냐...
            - 윈도우 사이즈만큼!!
            - 그럼 윈도우 사이즈를 4를 쓴다고 생각해보자
            - 그럼 시퀀스는 0 1 2 3이면 될텐데
            - 그럼 0 1 2 유실 유실 유실 유실 3
            - 이 문제 없는 것 처럼 느껴질 수 있다
            - 윈도우사이즈의 2배정도를 시퀀스 넘버로 쓰자!

            - 문제점
                - 모든 곳에 타이머를 달아야 됨
        6. tcp tcp는 한 쌍의 소켓끼리의 통신을 지원한다 = 포인트 투 포인트 순서대로 한다 한꺼번에 간다 full duflex 재전송할려면 센더에게도 버퍼가 있어야 한다 윈도우 사이즈 크기로
           리시브에게 버퍼가 있다 => 순서를 맞추려고 즉 각자가 2개씩 버퍼를 가짐 콘제스쳔 콘트롤 타이머 1개 쓴다 = go bacn n이랑 비슷 tcp는 타이머 터지면 그거에 헤당하는 거 하나만
           재전송한다
            1. tcp 세그먼트 구조
                - 목적지 포트번호
                - 도착지 포트번호
                - 시퀀스 번호
                    - 어플리케이션 레이어에서 내려온 데이터의 첫 번쨰 바이트 순서를 적어둠
                    - 이 번호는 보내는 자가 만들고 받는 사람은 그걸 따른다
                - 에크 넘버
                    - ack10 = 9번까지는 완벽하게 잘 받음 10번 줘
                    - 이 번호는 리시브 버퍼를 보고 요청하는 거니까 받는 사람이 만든 번호에 따라 결정됨
                    - tcp는 500ms를 기다렸다가 혹시 내가 보낼 데이터가 생기면 그 데이터 안에 이 에크를 실어서 보냄
                    - tcp 에크는 큐뮬레이티브 에크니까 500ms 기다렸다가 상황 보고 에크를 보내야 이득
                    - 받는 쪽에서 만약 ack10이 반복적으로 오면 유실 가능성이 높으므로 타이머 터지기 전에 미리 재전송
                        - 이걸 fast retransmit라고 함 = 권고사항정도임
                - 유실을 방지하기 위한 타임아웃
                    - rtt = 갔다 오는 시간 = 그떄마다 너무 다름
                    - rtt의 지수이동평균 + 마진
                - 체크썸
                - 리시브 윈도우
                - 리시브버퍼사이즈 10바이트
                    - tcp의 플로우 컨트롤
                    - 센더가 뭘 보낼 때 리시버가 받을 수 있는 만큼만 보내야 겠다
                    - 리시버가 센더에게 남은 공간이 얼마다라는걸 알려줘야댐
                    - 마안약에 리시버가 남은 공간이 0이라고 보내버리면?
                    - 센더는 흠... 하고 그떄부터 주기적으로 세그먼트에 헤더만 쓰고 데이터는 비워서 테스트로 보내봄
                    - 테스트해보니까 리시버가 드디어 준비가 됫다! 하면 이제 정상적으로 다시 보냄

            2. tcp의 3웨이 핸드 쉐이크
                1. 클라이언트가 syn segment를 보냄
                    1. 데이터는 없고 헤더에 syn이라는 1비트 필드 만들어 보냄
                    2. 나의 시퀀스 넘버가 뭐다 라고 상대에게 헤더를 통해 알려준다
                2. syn ack
                    1. syn 헤더 세팅해서 보냄
                    2. 받는 서버가 이제 자신의 시퀀스 넘버도 돌려줌
                3. ack
                    1. syn 필드는 0임
                    2. 데이터를 포함하고 있음
                        1. http라는걸 알려줄 수 있음
                    3. 왜 이걸 하냐?
                        1. 만약 2웨이라 하자 = 서버는 클라가 대체 된건지 안된건지 알 수가 없음
                4. 이게 완료 되면 이제 양쪽 다 버퍼를 만듬
                5. 커넥션을 끊을 떄도 비슷한 방식을 쓴다
                    1. fin을 보냄
                    2. 서버가 ack를 하고 자기 데이터 다 보낸 다음 역시 fin을 보냄
                    3. 클라가 확인용도로 ack 보냄 / 3초정도 쓰던 리소스와 자료구조를 유지함
                        1. 왜냐면 만약에 마지막에 보낸 ack가 유실된 경우 재전송해야되니까

            3. tcp의 콘제스쳔 컨트롤
                1. 네트워크가 나에게 알려줘(큐의 상황들을)
                    1. 이건 에바임 라우터 바빠
                2. 엔드 투 엔드 방식
                    1. 유추방식
                    2. ack의 동작 방식을 보고 유추한다
